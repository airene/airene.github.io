import{_ as t,c as a,o as i,ag as r}from"./chunks/framework.BmLMQRXF.js";const d=JSON.parse('{"title":"vue 性能优化的 9 个技巧","description":"业务系统可能不太在乎性能，写框架就会要求高不少","frontmatter":{"date":"2020-02-20T00:00:00.000Z","title":"vue 性能优化的 9 个技巧","category":"js","tags":["vue"],"description":"业务系统可能不太在乎性能，写框架就会要求高不少"},"headers":[],"relativePath":"posts/vue_optimize.md","filePath":"posts/vue_optimize.md"}'),l={name:"posts/vue_optimize.md"};function o(s,e,n,u,p,_){return i(),a("div",null,e[0]||(e[0]=[r('<h1 id="vue-性能优化的-9-个技巧" tabindex="-1">vue 性能优化的 9 个技巧 <a class="header-anchor" href="#vue-性能优化的-9-个技巧" aria-label="Permalink to &quot;vue 性能优化的 9 个技巧&quot;">​</a></h1><ul><li>无状态的函数式组件 核心就是vnode是普通的还是组件的(状态)</li><li>组件分离 子组件很耗时的话，还是vue的更新策略决定的(组件粒度)，分离之后相当于缓存了，如果是无状态计算属性也能干这个</li><li>局部变量 在用计算属性的时候参数是可以用当前可响应的属性或者变量解构进去使用，提升非常明显</li><li>v-if vs v-show 初始化 if快，高频更新 show更好</li><li>keepalive 没什么好说的，特定场景有奇效</li><li>Deferred features 不明觉厉，样例还是很明显的</li><li>Time slicing react好像就用到了这个，名词挺高级的，实际核心是requestAnimationFrame，总的时间变长，界面不卡</li><li>减少响应式引用，感觉和第二个有点像</li><li>虚拟滚动 可能大部分需要虚拟滚动的场景，有可能需求可以再提炼一下，总有别的方式可以做到，比如树滚动(按级加载)，表格滚动(数据需求提炼)，</li></ul><h2 id="资料" tabindex="-1">资料 <a class="header-anchor" href="#资料" aria-label="Permalink to &quot;资料&quot;">​</a></h2><p><a href="https://github.com/Akryum/vue-9-perf-secrets" target="_blank" rel="noreferrer">github</a><br><a href="https://slides.com/akryum/vueconfus-2019" target="_blank" rel="noreferrer">ppt</a></p>',4)]))}const m=t(l,[["render",o]]);export{d as __pageData,m as default};
