import{_ as a,o as s,c as r,z as e,a as i,t as n,O as o}from"./chunks/framework.7d395e2a.js";const T=JSON.parse('{"title":"你以为的 treeshaking 可能不是你以为的 treeshaking","description":"treeshaking最早由rollup实现，但是因为js语言本身的关系，和想象中差别还是挺大的","frontmatter":{"date":"2021-08-02T00:00:00.000Z","title":"你以为的 treeshaking 可能不是你以为的 treeshaking","tags":["treeshaking","esm"],"description":"treeshaking最早由rollup实现，但是因为js语言本身的关系，和想象中差别还是挺大的"},"headers":[],"relativePath":"posts/treeshaking.md","filePath":"posts/treeshaking.md"}'),l={name:"posts/treeshaking.md"},p={id:"frontmatter-title",tabindex:"-1"},h=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),c=o('<p>一个ui库的打包过程避免少不了treeshaking的内容，因为对于全局引入，组件库本身越大shake的优势越明显，</p><p>最近看了antdv，naiveui，nutui的实现，当前的基本上就两种：</p><ul><li>基于插件的导入转换，比如antdv</li><li>基于 package.json的sideEffects=false</li></ul><p>至于打包方式的话， webpack，rollup，<strong>不打包</strong>(naiveui)，vite的lib模式打包(nutui，treeshaking效果特别不好)</p><p><strong>当前即使到了webpack5</strong>，对于esm的打包支持依然不好。</p><p>关于treeshaking的一篇很不错的文章:</p><p><a href="https://github.com/wuomzfx/tree-shaking-test" target="_blank" rel="noreferrer">链接</a></p>',7);function _(t,g,d,k,f,u){return s(),r("div",null,[e("h1",p,[i(n(t.$frontmatter.title)+" ",1),h]),c])}const b=a(l,[["render",_]]);export{T as __pageData,b as default};
