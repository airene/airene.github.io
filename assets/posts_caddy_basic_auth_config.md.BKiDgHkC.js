import{_ as s,c as i,o as n,ag as e}from"./chunks/framework.DPDPlp3K.js";const k=JSON.parse('{"title":"caddy 的 basic_auth 在有 reserve_proxy 的情况下怎么一处配置，集体生效","description":"一个配置文件折腾了好久，gpt 和类 gpt 和 google 都不太能搜到结果（误导居多），最后无意中还是 gpt 解决了","frontmatter":{"date":"2025-01-10T00:00:00.000Z","title":"caddy 的 basic_auth 在有 reserve_proxy 的情况下怎么一处配置，集体生效","category":"caddy","tags":["caddy"],"description":"一个配置文件折腾了好久，gpt 和类 gpt 和 google 都不太能搜到结果（误导居多），最后无意中还是 gpt 解决了"},"headers":[],"relativePath":"posts/caddy_basic_auth_config.md","filePath":"posts/caddy_basic_auth_config.md"}'),t={name:"posts/caddy_basic_auth_config.md"};function p(h,a,l,r,d,c){return n(),i("div",null,a[0]||(a[0]=[e(`<h1 id="caddy-的-basic-auth-在有-reserve-proxy-的情况下怎么一处配置-集体生效" tabindex="-1">caddy 的 basic_auth 在有 reserve_proxy 的情况下怎么一处配置，集体生效 <a class="header-anchor" href="#caddy-的-basic-auth-在有-reserve-proxy-的情况下怎么一处配置-集体生效" aria-label="Permalink to &quot;caddy 的 basic_auth 在有 reserve_proxy 的情况下怎么一处配置，集体生效&quot;">​</a></h1><h2 id="场景" tabindex="-1">场景 <a class="header-anchor" href="#场景" aria-label="Permalink to &quot;场景&quot;">​</a></h2><p>在单个子域名多个项目的时候有用，直接上结果</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">demo.example.com {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    basic_auth {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        ad hash_password</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 要用caddy命令生成</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 后端项目1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    handle_path /be1/* {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        reverse_proxy 127.0.0.1:8093 {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            header_up Authorization {http.auth.header}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 后端项目2</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    handle_path /be2/* {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        reverse_proxy 127.0.0.1:8095 {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            header_up Authorization {http.auth.header}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 前端地址，所有项目都在一起</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    reverse_proxy  http://127.0.0.1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>最重要的坑点就是搜出来的都是 <code>header_up Authorization {http.auth.header.Authorization}</code> ，而不是现在的写法</p><h2 id="扩展" tabindex="-1">扩展 <a class="header-anchor" href="#扩展" aria-label="Permalink to &quot;扩展&quot;">​</a></h2><p>handle 和 handle_path 的区别主要就是在对路径的处理上，这个很简单。</p>`,7)]))}const _=s(t,[["render",p]]);export{k as __pageData,_ as default};
