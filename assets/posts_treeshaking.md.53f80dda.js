import{_ as a,o as s,c as r,d as e,e as i,t as n,f as o}from"./app.6ba37ee0.js";const T=JSON.parse('{"title":"你以为的 treeshaking 可能不是你以为的 treeshaking","description":"treeshaking最早由rollup实现，但是因为js语言本身的关系，和想象中差别还是挺大的","frontmatter":{"date":"2021-08-02T00:00:00.000Z","title":"你以为的 treeshaking 可能不是你以为的 treeshaking","tags":["treeshaking","esm"],"description":"treeshaking最早由rollup实现，但是因为js语言本身的关系，和想象中差别还是挺大的"},"headers":[],"relativePath":"posts/treeshaking.md"}'),p={name:"posts/treeshaking.md"},l={id:"frontmatter-title",tabindex:"-1"},c=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),h=o('<p>一个ui库的打包过程避免少不了treeshaking的内容，因为对于全局引入，组件库本身越大shake的优势越明显，</p><p>最近看了antdv，naiveui，nutui的实现，当前的基本上就两种：</p><ul><li>基于插件的导入转换，比如antdv</li><li>基于 package.json的sideEffects=false</li></ul><p>至于打包方式的话， webpack，rollup，<strong>不打包</strong>(naiveui)，vite的lib模式打包(nutui，treeshaking效果特别不好)</p><p><strong>当前即使到了webpack5</strong>，对于esm的打包支持依然不好。</p><p>关于treeshaking的一篇很不错的文章:</p><p><a href="https://github.com/wuomzfx/tree-shaking-test" target="_blank" rel="noreferrer">链接</a></p>',7);function _(t,d,g,k,u,f){return s(),r("div",null,[e("h1",l,[i(n(t.$frontmatter.title)+" ",1),c]),h])}const v=a(p,[["render",_]]);export{T as __pageData,v as default};
