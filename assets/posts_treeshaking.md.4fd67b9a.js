import{o as e,c as t,f as a}from"./app.4a562384.js";const r='{"title":"你以为的treeshaking可能不是你以为的treeshaking","description":"treeshaking最早由rollup实现，但是因为js语言本身的关系，和想象中差别还是挺大的","frontmatter":{"date":"2021-08-02","title":"你以为的treeshaking可能不是你以为的treeshaking","tags":["treeshaking","esm"],"description":"treeshaking最早由rollup实现，但是因为js语言本身的关系，和想象中差别还是挺大的"},"relativePath":"posts/treeshaking.md","lastUpdated":1629188549131}',s={},i=[a('<h1 id="你以为的treeshaking可能不是你以为的treeshaking"><a class="header-anchor" href="#你以为的treeshaking可能不是你以为的treeshaking" aria-hidden="true">#</a> 你以为的treeshaking可能不是你以为的treeshaking</h1><p>一个ui库的打包过程避免少不了treeshaking的内容，因为对于全局引入，组件库本身越大shake的优势越明显，</p><p>最近看了antdv，naiveui，nutui的实现，当前的基本上就两种：</p><ul><li>基于插件的导入转换，比如antdv</li><li>基于 package.json的sideEffects=false</li></ul><p>至于打包方式的话， webpack，rollup，<strong>不打包</strong>(naiveui)，vite的lib模式打包(nutui，treeshaking效果特别不好)</p><p><strong>当前即使到了webpack5</strong>，对于esm的打包支持依然不好。</p><p>关于treeshaking的一篇很不错的文章:</p><p><a href="https://github.com/wuomzfx/tree-shaking-test" target="_blank" rel="noopener noreferrer">链接</a></p>',8)];s.render=function(a,r,s,n,h,p){return e(),t("div",null,i)};export{r as __pageData,s as default};
