import{o as a,c as n,f as s}from"./app.eb35be3c.js";const p='{"title":"TS之协变逆变","description":"深入学习Typescript的关键特性之 Covariance and contravariance","frontmatter":{"date":"2021-08-08","title":"TS之协变逆变","description":"深入学习Typescript的关键特性之 Covariance and contravariance","tags":["ts"]},"headers":[{"level":2,"title":"协变的例子","slug":"协变的例子"},{"level":2,"title":"逆变的例子","slug":"逆变的例子"},{"level":2,"title":"双向协变","slug":"双向协变"}],"relativePath":"posts/ts_covariance_contravariance.md","lastUpdated":1630328512813}',t={},e=[s('<h1 id="typescript的协变和逆变是什么"><a class="header-anchor" href="#typescript的协变和逆变是什么" aria-hidden="true">#</a> typescript的协变和逆变是什么</h1><p>typescript除了静态类型检查，其实还有一各特点说的很恰当，就是<code>类型编程</code>，这点与java对比的话，比java灵活的多。 如果有面向对象编程基础的话，看泛型并不难，从教程中看到协变、逆变这两个词就有点高大上，再看wiki定义</p><blockquote><p>协变与逆变(Covariance and contravariance )是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p></blockquote><p>懵不懵？</p><p>白话版：具有父子关系的多个类型，在通过某种构造关系构造成的新的类型，如果还具有父子关系则是协变的，而关系逆转了就是逆变的</p><h2 id="协变的例子"><a class="header-anchor" href="#协变的例子" aria-hidden="true">#</a> 协变的例子</h2><p>和java类似的，从对象的角度来讲，Animal 是父类，Dog是子类，子类更具象，属性或者方法更多，向上赋值没问题，可以理解为<code>砍掉</code>了多余的属性</p><div class="language-js"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> string<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token function">wangwang</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> animal1<span class="token operator">:</span> Animal<span class="token punctuation">;</span>\n<span class="token keyword">let</span> dog1<span class="token operator">:</span> Dog<span class="token punctuation">;</span>\nanimal1 <span class="token operator">=</span> dog1<span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> arrAnimal<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span>\n<span class="token keyword">let</span> arrDog<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span>\n<span class="token comment">// 兼容，可以赋值，这个就是协变，也就是Array衍生后的类型是协变</span>\narrAnimal <span class="token operator">=</span> arrDog\n</code></pre></div><h2 id="逆变的例子"><a class="header-anchor" href="#逆变的例子" aria-hidden="true">#</a> 逆变的例子</h2><p>具有父子关系的类型，如果用在函数参数的时候，与原始类型项目，赋值兼容性相反了，就是逆变，<code>从函数调用来讲，成员属性和方法要全乎的才能调用，不然如果实现里面用到了没有的属性就操作了呀</code></p><div class="language-js"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> string<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token function">wangwang</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\ntype <span class="token function-variable function">AnimalFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arg<span class="token operator">:</span> Animal</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>\ntype <span class="token function-variable function">DogFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arg<span class="token operator">:</span> Dog</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>\n\n<span class="token keyword">let</span> animalFn<span class="token operator">:</span> AnimalFn<span class="token punctuation">;</span>\n<span class="token keyword">let</span> dogFn<span class="token operator">:</span> DogFn<span class="token punctuation">;</span>\n<span class="token comment">// 这样不行</span>\nanimalFn <span class="token operator">=</span> dogFn<span class="token punctuation">;</span>\n<span class="token comment">// 这样可以 也就是放在函数参数上的话 函数之间的关系逆变了</span>\ndogFn <span class="token operator">=</span> animalFn<span class="token punctuation">;</span>\n</code></pre></div><h2 id="双向协变"><a class="header-anchor" href="#双向协变" aria-hidden="true">#</a> 双向协变</h2><p>Ts在函数参数的比较中实际上默认采取的策略是双向协变：只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。</p><p>如果害怕调用出问题，可以通过<code>tsconfig.js</code>中修改<code>strictFunctionType</code>属性来严格控制协变和逆变。</p>',14)];t.render=function(s,p,t,o,c,r){return a(),n("div",null,e)};export{p as __pageData,t as default};
